Object subclass: #PcmBlock	instanceVariableNames: 'announcer'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmBlock methodsFor: 'accessing' stamp: 'xxx 12/3/2017 23:28'!announcer	^ announcer ifNil: [ announcer := Announcer new. ]! !!PcmBlock methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:41'!view	self subclassResponsibility! !BlElement subclass: #PcmBlockView	instanceVariableNames: 'model'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmBlockView methodsFor: 'initialization' stamp: 'xxx 12/3/2017 22:05'!initialize	super initialize.	self size: 32 @ 32.	self layout: BlLinearLayout vertical.	self layout alignCenter.! !!PcmBlockView methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:46'!model: aPcmBlock	model := aPcmBlock! !!PcmBlockView methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:53'!model	^ model! !Object subclass: #PcmConsumable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmConsumable methodsFor: 'as yet unclassified' stamp: 'FK 12/14/2017 00:10'!applyEffectOn: anObject	self subclassResponsibility ! !PcmConsumable subclass: #PcmBigDot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmBigDot methodsFor: 'accessing' stamp: 'FK 12/14/2017 00:12'!view	^ PcmBigDotView new! !Object subclass: #PcmDir	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDir commentStamp: 'FK 12/27/2017 23:00' prior: 0!This class is for accessing direction singletons with better readable code!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PcmDir class	instanceVariableNames: ''!!PcmDir class methodsFor: 'actions' stamp: 'FK 12/27/2017 23:11'!up	^ PcmDirUp uniqueInstance! !!PcmDir class methodsFor: 'actions' stamp: 'FK 12/27/2017 23:11'!down	^ PcmDirDown uniqueInstance! !!PcmDir class methodsFor: 'actions' stamp: 'FK 12/27/2017 23:12'!right	^ PcmDirRight uniqueInstance! !!PcmDir class methodsFor: 'actions' stamp: 'FK 12/27/2017 23:12'!null	^ PcmDirNull uniqueInstance! !!PcmDir class methodsFor: 'actions' stamp: 'FK 12/27/2017 23:11'!left	^ PcmDirLeft uniqueInstance! !!PcmDir class methodsFor: 'instance creation' stamp: 'FK 12/27/2017 22:59'!new	self error: 'This class is not supposed to have instances'! !Object subclass: #PcmDirection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDirection commentStamp: 'FK 12/27/2017 23:01' prior: 0!Abstract class for directions!!PcmDirection methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:11'!opposite	self subclassResponsibility ! !!PcmDirection methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:25'!direction	self subclassResponsibility ! !!PcmDirection methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:18'!vector	self subclassResponsibility ! !!PcmDirection methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 21:08'!moveInDirection: anObject	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PcmDirection class	instanceVariableNames: 'instance'!!PcmDirection class methodsFor: 'accessing' stamp: 'FK 12/27/2017 22:55'!uniqueInstance	instance ifNil: [ instance := self basicNew initialize ].	^ instance! !!PcmDirection class methodsFor: 'instance creation' stamp: 'FK 12/27/2017 23:16'!new	self error:  'PcmDirections are not meant to have more instances'! !PcmDirection subclass: #PcmDirDown	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDirDown commentStamp: 'FK 12/27/2017 23:02' prior: 0!This class represents direction down in our game!!PcmDirDown methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:21'!opposite	^ PcmDirUp uniqueInstance ! !!PcmDirDown methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:26'!direction	^ 'd'! !!PcmDirDown methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:18'!vector	^ 0@1! !!PcmDirDown methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 21:09'!moveInDirection: anObject	anObject moveDown! !PcmDirection subclass: #PcmDirLeft	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDirLeft commentStamp: 'FK 12/27/2017 23:02' prior: 0!This class represents direction left in our game!!PcmDirLeft methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:22'!opposite	^ PcmDirRight uniqueInstance ! !!PcmDirLeft methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:26'!direction	^ 'l'! !!PcmDirLeft methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:19'!vector	^ -1@0! !!PcmDirLeft methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 21:09'!moveInDirection: anObject	anObject moveLeft! !PcmDirection subclass: #PcmDirNull	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDirNull commentStamp: 'FK 12/27/2017 23:02' prior: 0!This class represents direction null object  in our game!!PcmDirNull methodsFor: 'accessing' stamp: 'FK 12/27/2017 22:07'!opposite	^ self! !!PcmDirNull methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:26'!direction	^ 'n'! !!PcmDirNull methodsFor: 'accessing' stamp: 'FK 12/27/2017 22:07'!vector	^ 0@0! !!PcmDirNull methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 22:07'!moveInDirection: anObject	^ self! !PcmDirection subclass: #PcmDirRight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDirRight commentStamp: 'FK 12/27/2017 23:03' prior: 0!This class represents direction right in our game!!PcmDirRight methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 21:09'!moveInDirection: anObject	anObject moveRight! !!PcmDirRight methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:21'!opposite	^ PcmDirLeft uniqueInstance ! !!PcmDirRight methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:26'!direction	^ 'r'! !!PcmDirRight methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:19'!vector	^ 1@0! !PcmDirection subclass: #PcmDirUp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDirUp commentStamp: 'FK 12/27/2017 23:03' prior: 0!This class represents direction up in our game!!PcmDirUp methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 21:10'!moveInDirection: anObject	anObject moveUp! !!PcmDirUp methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:22'!opposite	^ PcmDirDown uniqueInstance ! !!PcmDirUp methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:26'!direction	^ 'u'! !!PcmDirUp methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:19'!vector	^ 0@(-1).! !BlElement subclass: #PcmDotView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmDotView methodsFor: 'drawing' stamp: 'xxx 12/3/2017 22:40'!drawOnSpartaCanvas: aCanvas	aCanvas fill		paint: Color yellow;		path: (aCanvas shape ellipse: self boundsInLocal);		draw! !PcmDotView subclass: #PcmBigDotView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmBigDotView methodsFor: 'initialization' stamp: 'xxx 12/3/2017 22:28'!initialize	super initialize.	self size: 12 @ 12.! !Object subclass: #PcmGame	instanceVariableNames: 'map pacman ghosts ticker space inky clyde blinky pinky points announcer gameView isHunting'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmGame methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 12/27/2017 14:40'!doTick	pacman move: map.	ghosts		do: [ :ghost | 			ghost decideOnMap: map to: pacman.			ghost move: map.			(ghost collidesWith: pacman)				ifTrue: [ self handleGhostCollision: ghost  ] ].	ticker fire: [ self doTick ] after: 10! !!PcmGame methodsFor: 'as yet unclassified' stamp: 'AdamPlatkevic 12/17/2017 14:42'!loadMap	| ios currentLine block |	map := PcmMap new.	ios := FileStream oldFileNamed: 'map.txt'.	map columnsCnt: ios nextLine asNumber.	map rowsCnt: ios nextLine asNumber.	1 to: map rowsCnt do: [ :i | 		currentLine := ios nextLine.		1 to: map columnsCnt do: [ :j | 			(currentLine at: j) = $1				ifTrue: [ map addBlock: PcmWall new ].			(currentLine at: j) = $3				ifTrue: [ 					block := PcmCoridor new.					block item: PcmSmallDot new.					block announcer when: PcmItemConsumed send: #handleSmallDotConsumed to: self.					map addBlock: block.					].			(currentLine at: j) = $4				ifTrue: [ 					block := PcmCoridor new.					block item: PcmBigDot new.					block announcer when: PcmItemConsumed send: #handleBigDotConsumed to: self.					map addBlock: block.					].			(currentLine at: j) = $0				ifTrue: [ map addBlock: PcmCoridor new ].			(currentLine at: j) = $2				ifTrue: [ map addBlock: PcmGhostDoor new ] ] ].	ios close.	gameView := PcmGameView new gameModel: self! !!PcmGame methodsFor: 'as yet unclassified' stamp: 'AdamPlatkevic 12/17/2017 15:39'!handleSmallDotConsumed		points := points + 10.	self announcer announce: (PcmPointsChanged new points: points; yourself).! !!PcmGame methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 12/27/2017 15:03'!handleBigDotConsumed	Transcript		show: 'Big dot consumed';		cr.	ghosts do: [ :g | g finder: PcmHuntRouteFinder new ].	isHunting := true.! !!PcmGame methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 12/27/2017 14:46'!resetGhosts	ghosts do: [ :g | g resetOn: map ]! !!PcmGame methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 12/27/2017 15:02'!handleGhostCollision: ghost	"react to a collision with ghost"	"TODO: decrement lifes and do stuff"	isHunting ifTrue: [ ghost resetOn: map ] ifFalse: [ ghosts do: [ :g | g resetOn: map  ] ]	! !!PcmGame methodsFor: 'as yet unclassified' stamp: 'AdamPlatkevic 12/17/2017 14:24'!handleGhostCollision	"react to a collision with ghost"	"TODO: decrement lifes and do stuff"	self resetGhosts.	! !!PcmGame methodsFor: 'accessing' stamp: 'AdamPlatkevic 12/17/2017 14:47'!map	^ map! !!PcmGame methodsFor: 'accessing' stamp: 'FK 12/26/2017 19:56'!points	^ points! !!PcmGame methodsFor: 'accessing' stamp: 'AdamPlatkevic 12/17/2017 14:35'!announcer	^ announcer ifNil: [ announcer := Announcer new. ]! !!PcmGame methodsFor: 'initialization' stamp: 'FK 12/27/2017 20:58'!initialize	super initialize.	points := 0.	isHunting := false.	self loadMap.	self announcer		announce:			(PcmPointsChanged new				points: points;				yourself).	space := BlSpace new.	space root addChild: gameView.	ghosts := OrderedCollection new.	self initObjects.	space show.	ticker := PcmTicker withTick: 1.	ticker fire: [ self doTick ] after: 20.	ticker fire: [ (space root children at: 2) animate: ticker ] after: 20.	self setKeyboardEvents.	[ ticker run ] fork! !!PcmGame methodsFor: 'initialization' stamp: 'FK 12/27/2017 23:14'!setKeyboardEvents	space		addEventHandler:			(BlEventHandler				on: BlKeyDownEvent				do: [ :anEvent | 					anEvent key = Key arrowDown						ifTrue: [ pacman directionChangeRequest: PcmDir down ].					anEvent key = Key arrowUp						ifTrue: [ pacman directionChangeRequest: PcmDir up ].					anEvent key = Key arrowRight						ifTrue: [ pacman directionChangeRequest: PcmDir right ].					anEvent key = Key arrowLeft						ifTrue: [ pacman directionChangeRequest: PcmDir left ].					anEvent key = Key escape						ifTrue: [ ticker stop ] ])! !!PcmGame methodsFor: 'initialization' stamp: 'OndrejPleticha 12/27/2017 14:57'!initObjects	pacman := PcmPacman new.	inky := PcmInky new.	blinky := PcmBlinky new.	clyde := PcmClyde new.	pinky := PcmPinky new.	space root addChild: pacman view.	space root addChild: inky view.	space root addChild: clyde view.	space root addChild: pinky view.	space root addChild: blinky view.	ghosts add: blinky.	ghosts add: inky.	ghosts add: clyde.	ghosts add: pinky.	self resetGhosts.	pacman resetOn: map.! !BlElement subclass: #PcmGameView	instanceVariableNames: 'gameModel mapView pointsView'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmGameView methodsFor: 'initialization' stamp: 'FK 12/27/2017 21:05'!initialize	super initialize.	mapView := PcmMapView new.	self addChild: mapView.	pointsView := PcmScoreView new.	self addChild: pointsView.	self layout: BlGridLayout vertical.	self		constraintsDo: [ :aLayoutConstraints | 			aLayoutConstraints horizontal fitContent.			aLayoutConstraints vertical fitContent ]! !!PcmGameView methodsFor: 'accessing' stamp: 'AdamPlatkevic 12/17/2017 14:40'!gameModel	^ gameModel! !!PcmGameView methodsFor: 'accessing' stamp: 'FK 12/27/2017 21:05'!gameModel: aPcmGame	gameModel := aPcmGame.	mapView mapModel: aPcmGame map.	pointsView model: self gameModel.	! !Object subclass: #PcmHuntRouteFinder	instanceVariableNames: 'startNode endNode fifo map'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:24'!startNode^ startNode ! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:21'!startNode: nodestartNode := node! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:24'!map: amapmap:= amap! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:22'!endNode^ endNode ! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:32'!runFor: aPcmMovingBlock	| closeSet openSet dict parent_state |	startNode = endNode		ifTrue: [ ^ nil ].	closeSet := Set new.	openSet := OrderedCollection new.	dict := Dictionary new.	dict at: self startNode put: nil.	openSet add: self startNode.	[ openSet notEmpty ]		whileTrue: [ parent_state := openSet at: 1.			openSet remove: parent_state.			endNode = parent_state				ifTrue: [ ^ (self getFirstDir: dict)  ].			(map getFreeBlockAround: parent_state for: aPcmMovingBlock)				do: [ :child | 					(closeSet includes: child)						ifFalse: [ (openSet includes: child)								ifFalse: [ dict at: child put: parent_state.									openSet add: child ] ] ].			closeSet add: parent_state ]! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:23'!endNode: nodeendNode := node! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:28'!getFirstDir: aDict	| curr |	curr := endNode deepCopy.	[ true ]		whileTrue: [ (aDict at: curr) = startNode				ifTrue: [ ^ (map getDirFrom: startNode to: curr) opposite ]				ifFalse: [ curr := aDict at: curr ] ]! !!PcmHuntRouteFinder methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:23'!map^ map! !Announcement subclass: #PcmItemConsumed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!Object subclass: #PcmMap	instanceVariableNames: 'columnsCnt rowsCnt blocks'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmMap methodsFor: 'as yet unclassified' stamp: 'FK 12/14/2017 00:22'!getNeighbouringIndexes: aIndex	| indexes |	indexes := OrderedCollection new.	indexes		add: aIndex - self columnsCnt;		add: aIndex + self columnsCnt;		add: aIndex + 1;		add: aIndex - 1.	^ indexes! !!PcmMap methodsFor: 'as yet unclassified' stamp: 'FK 12/14/2017 00:36'!getFreeBlockAround: aIndex for: aPcmMovingBlock	^ ((self getNeighbouringIndexes: aIndex) select: [ :each | (self getBlock: each) canGoThrough: aPcmMovingBlock ])		asOrderedCollection! !!PcmMap methodsFor: 'initialization' stamp: 'xxx 11/21/2017 22:52'!initialize	super initialize.	blocks := OrderedCollection new.! !!PcmMap methodsFor: 'adding' stamp: 'AdamPlatkevic 12/17/2017 13:40'!addBlock: aStaticBlock	blocks add: aStaticBlock! !!PcmMap methodsFor: 'accessing' stamp: 'xxx 11/21/2017 22:50'!rowsCnt: anNumber	rowsCnt := anNumber! !!PcmMap methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:00'!getBlock: aNumber	^ blocks at: aNumber! !!PcmMap methodsFor: 'accessing' stamp: 'xxx 11/21/2017 22:50'!columnsCnt: aNumber	columnsCnt := aNumber! !!PcmMap methodsFor: 'accessing' stamp: 'FK 12/14/2017 00:33'!isCrossroad: aIndex for: aPcmMovingBlock	^ (self getFreeBlockAround: aIndex for: aPcmMovingBlock) size > 2 ! !!PcmMap methodsFor: 'accessing' stamp: 'xxx 11/21/2017 22:49'!rowsCnt	^ rowsCnt! !!PcmMap methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:18'!getDirFrom: start to: end		end - 1 = start		ifTrue: [ ^ PcmDir right ].	end + 1 = start		ifTrue: [ ^ PcmDir left ].	end + self columnsCnt = start		ifTrue: [ ^ PcmDir up ].	end - self columnsCnt = start		ifTrue: [ ^ PcmDir down ]! !!PcmMap methodsFor: 'accessing' stamp: 'xxx 11/21/2017 22:49'!columnsCnt	^ columnsCnt! !!PcmMap methodsFor: 'accessing' stamp: 'xxx 11/22/2017 00:03'!blocks	^ blocks ! !BlElement subclass: #PcmMapView	instanceVariableNames: 'mapModel'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmMapView methodsFor: 'accessing' stamp: 'xxx 12/3/2017 22:48'!mapModel: aPcmMap	mapModel := aPcmMap. 	self layout columnCount: mapModel columnsCnt.	mapModel blocks 		do: [ :aBlock | self addChild: (aBlock view) ]! !!PcmMapView methodsFor: 'initialization' stamp: 'xxx 11/21/2017 23:30'!initialize	super initialize.	self layout: BlGridLayout horizontal.	"self layout columnCount: columns."	self		constraintsDo: [ :aLayoutConstraints | 		aLayoutConstraints horizontal fitContent.		aLayoutConstraints vertical fitContent ].! !PcmBlock subclass: #PcmMovingBlock	instanceVariableNames: 'x y coordinate directionChangeRequest direction'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmMovingBlock methodsFor: 'testing' stamp: 'FK 12/14/2017 00:15'!canGoThroughGhostDoor	self subclassResponsibility ! !!PcmMovingBlock methodsFor: 'testing' stamp: 'FK 12/14/2017 00:15'!canGoThroughCoridor	self subclassResponsibility ! !!PcmMovingBlock methodsFor: 'testing' stamp: 'FK 12/14/2017 00:15'!canGoThroughWall	self subclassResponsibility ! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:07'!changeDirection: aPcmMap	| change |	directionChangeRequest ifNil: [ ^ self ].	change := directionChangeRequest.	directionChangeRequest := nil.	direction		ifNotNil: [ direction == change				ifTrue: [ ^ self ].			direction = change opposite				ifTrue: [ direction := change.					self announcer announce: PcmPacmanChangedDirection new.					^ self ] ].	(x \\ 32 = 0 and: y \\ 32 = 0)		ifTrue: [ (self canGoThroughNextBlock: aPcmMap direction: change)				ifTrue: [ direction := change.					self announcer announce: PcmPacmanChangedDirection new.					^ self ] ].	directionChangeRequest ifNil: [ directionChangeRequest := change ]! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:44'!moveUp	y := y - 1! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 11:38'!announcer	^ announcer ifNil: [ announcer := Announcer new. ]! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:42'!direction: aDirection	direction := aDirection! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:42'!direction	^ direction! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:18'!x	^ x! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:18'!y	^ y! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:44'!moveLeft	x := x - 1! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:38'!directionChangeRequest: aPcmDirection	directionChangeRequest := aPcmDirection! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'FK 12/27/2017 23:19'!move: aPcmMap	directionChangeRequest ifNotNil: [ self changeDirection: aPcmMap ].	(x \\ 32 = 0 and: y \\ 32 = 0)		ifTrue: [ (self canGoThroughNextBlock: aPcmMap direction: direction)				ifFalse: [ direction := PcmDir null ] ].	direction moveInDirection: self.	self computeCurrentCoordinate: aPcmMap.	self announcer announce: PcmPacmanMoved new! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:18'!x: aNumber	x := aNumber! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:44'!moveRight	x := x + 1! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'FK 12/27/2017 22:30'!canGoThroughNextBlock: aPcmMap direction: aPcmDirection	^ (aPcmMap getBlock: coordinate + (aPcmDirection vector x * 1) + (aPcmDirection vector y * aPcmMap columnsCnt)) canGoThrough: self! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:18'!y: aNumber	y := aNumber ! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:44'!moveDown	y := y + 1! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 12:52'!coordinate: aNumber	coordinate := aNumber! !!PcmMovingBlock methodsFor: 'accessing' stamp: 'OndrejPleticha 12/9/2017 15:34'!coordinate	^ coordinate ! !!PcmMovingBlock methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 11/27/2017 11:38'!forceViewRelocate	self announcer announce: PcmPacmanMoved new! !!PcmMovingBlock methodsFor: 'as yet unclassified' stamp: 'xxx 12/3/2017 23:43'!computeCurrentCoordinate: aPcmMap	| newCoordinate |	newCoordinate := (y + 16) // 32 * aPcmMap columnsCnt		+ ((x + 16) // 32) + 1.	coordinate ~= newCoordinate		ifTrue: [ coordinate := newCoordinate.			(aPcmMap getBlock: coordinate) consumeItem ]! !!PcmMovingBlock methodsFor: 'initialization' stamp: 'FK 12/27/2017 23:13'!initialize	super initialize.	direction := PcmDir null ! !PcmMovingBlock subclass: #PcmGhost	instanceVariableNames: 'finder'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmGhost methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 23:10'!decideOnMap: aMap to: aPacman	|random |	(x \\ 32 = 0 and: y \\ 32 = 0)		ifFalse: [ ^ self ].	"& (aMap isCrossroad: self coordinate)"	" )"	random := 2 atRandom.	random = 1		ifTrue: [ 			finder startNode: self coordinate.			finder endNode: aPacman coordinate.			finder map: aMap.			self directionChangeRequest: (finder runFor: self) ]		ifFalse: [ random := 4 atRandom.			random = 1				ifTrue: [ directionChangeRequest := PcmDir right ].			random = 2				ifTrue: [ directionChangeRequest := PcmDir down ].			random = 3				ifTrue: [ directionChangeRequest := PcmDir left ].			random = 4				ifTrue: [ directionChangeRequest := PcmDir up ] ]! !!PcmGhost methodsFor: 'as yet unclassified' stamp: 'ondra 12/13/2017 12:01'!collidesWith: aPcmPacman	"detect my collision with pacman based on squared distance"	^ (aPcmPacman x - self x) abs + (aPcmPacman y - self y) abs < 23! !!PcmGhost methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 12/9/2017 15:37'!computeCurrentCoordinate: aPcmMap	| newCoordinate |	newCoordinate := (y + 16) // 32 * aPcmMap columnsCnt		+ ((x + 16) // 32) + 1.	coordinate := newCoordinate		! !!PcmGhost methodsFor: 'testing' stamp: 'OndrejPleticha 12/27/2017 14:28'!initialize	super initialize.	finder:= PcmRouteFinder new.		! !!PcmGhost methodsFor: 'testing' stamp: 'FK 12/14/2017 00:16'!canGoThroughGhostDoor	^ true! !!PcmGhost methodsFor: 'testing' stamp: 'FK 12/14/2017 00:16'!canGoThroughCoridor	^ true! !!PcmGhost methodsFor: 'testing' stamp: 'FK 12/14/2017 00:16'!canGoThroughWall	^ false! !!PcmGhost methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:26'!finder	^ finder ! !!PcmGhost methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:26'!finder: aFinder	finder := aFinder.! !PcmGhost subclass: #PcmBlinky	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmBlinky methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:54'!resetOn: aMap	x := 160.	y := 96.	self computeCurrentCoordinate: aMap.	self forceViewRelocate.! !!PcmBlinky methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 11:39'!view	^ PcmBlinkyView  new model: self ! !PcmGhost subclass: #PcmClyde	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmClyde methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:55'!resetOn: aMap	x := 224.	y := 96.	self computeCurrentCoordinate: aMap.	self forceViewRelocate! !!PcmClyde methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 11:39'!view	^ PcmClydeView  new model: self ! !PcmGhost subclass: #PcmInky	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmInky methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:55'!resetOn: aMap	x := 288.	y := 96.	self computeCurrentCoordinate: aMap.	self forceViewRelocate! !!PcmInky methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 11:10'!view	^ PcmInkyView  new model: self ! !PcmBlockView subclass: #PcmMovingView	instanceVariableNames: 'tick maxTick lastDirection'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmMovingView methodsFor: 'accessing' stamp: 'OndrejPleticha 11/28/2017 08:14'!background	tick := (tick + 1) \\ (maxTick + 1).	"when i tried this at method move, Pharo froze on saving the change :) "	^ BlBackground builder		image:			((Form fromFileNamed: './pacman_images/pacman-' , lastDirection direction , tick asString , '.png')				magnifyBy: 1.4);		opacity: 1;		build! !!PcmMovingView methodsFor: 'accessing' stamp: 'xxx 11/22/2017 19:23'!move	self relocate: (model x)@(model y)! !!PcmMovingView methodsFor: 'accessing' stamp: 'xxx 11/22/2017 21:34'!model: aPcmPacman	model := aPcmPacman.	model announcer when: PcmPacmanMoved send: #move to: self.	model announcer when: PcmPacmanChangedDirection  send: #changeDirection to: self! !!PcmMovingView methodsFor: 'initialization' stamp: 'FK 12/27/2017 23:17'!initialize	super initialize.	lastDirection := PcmDir right.	tick := 0.	maxTick := 5.! !!PcmMovingView methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 23:24'!changeDirection	lastDirection := model direction.! !!PcmMovingView methodsFor: 'drawing' stamp: 'xxx 11/22/2017 21:15'!drawOnSpartaCanvas: aCanvas	self background drawOnSpartaCanvas: aCanvas of: self! !PcmMovingView subclass: #PcmGhostView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!PcmGhostView subclass: #PcmBlinkyView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmBlinkyView methodsFor: 'accessing' stamp: 'FK 12/4/2017 20:43'!background	tick := (tick + 1) \\ (maxTick + 1). "when i tried this at method move, Pharo froze on saving the change :) "	^ BlBackground builder		paint: Color transparent;		image:			((Form fromFileNamed: './pacman_images/ghost1_' , lastDirection  direction, '1', '.png')				magnifyBy: 1.4);		opacity: 1;		build! !PcmGhostView subclass: #PcmClydeView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmClydeView methodsFor: 'accessing' stamp: 'FK 12/4/2017 20:42'!background	tick := (tick + 1) \\ (maxTick + 1). "when i tried this at method move, Pharo froze on saving the change :) "	^ BlBackground builder		paint: Color transparent;		image:			((Form fromFileNamed: './pacman_images/ghost2_' , lastDirection direction  , '1', '.png')				magnifyBy: 1.4);		opacity: 1;		build! !PcmGhostView subclass: #PcmInkyView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmInkyView methodsFor: 'accessing' stamp: 'FK 12/4/2017 20:42'!background	tick := (tick + 1) \\ (maxTick + 1). "when i tried this at method move, Pharo froze on saving the change :) "	^ BlBackground builder		paint: Color transparent;		image:			((Form fromFileNamed: './pacman_images/ghost5_' , lastDirection  direction , '1', '.png')				magnifyBy: 1.4);		opacity: 1;		build! !PcmMovingBlock subclass: #PcmPacman	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmPacman methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:54'!resetOn: aMap	x := 32.	y := 32.	self computeCurrentCoordinate: aMap.	self forceViewRelocate.! !!PcmPacman methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 11:01'!view	^ PcmPacmanView  new model: self ! !!PcmPacman methodsFor: 'testing' stamp: 'FK 12/14/2017 00:16'!canGoThroughGhostDoor	^ false! !!PcmPacman methodsFor: 'testing' stamp: 'FK 12/14/2017 00:16'!canGoThroughCoridor	^ true! !!PcmPacman methodsFor: 'testing' stamp: 'FK 12/14/2017 00:16'!canGoThroughWall	^ false! !Announcement subclass: #PcmPacmanChangedDirection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!Announcement subclass: #PcmPacmanMoved	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!PcmMovingView subclass: #PcmPacmanView	instanceVariableNames: 'animationTime'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmPacmanView methodsFor: 'accessing' stamp: 'FK 12/4/2017 20:41'!background	^ BlBackground builder		paint: Color transparent;		image:			((Form fromFileNamed: './pacman_images/pacman-' , lastDirection direction , tick asString , '.png')				magnifyBy: 1.4);		opacity: 1;		build! !!PcmPacmanView methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 10:59'!model: aPcmPacman	model := aPcmPacman.	model announcer when: PcmPacmanMoved send: #move to: self.	model announcer when: PcmPacmanChangedDirection  send: #changeDirection to: self! !!PcmPacmanView methodsFor: 'initialization' stamp: 'FK 12/4/2017 20:35'!initialize	super initialize.	animationTime := 30.! !!PcmPacmanView methodsFor: 'as yet unclassified' stamp: 'OndrejPleticha 11/27/2017 10:55'!changeDirection	lastDirection := model direction! !!PcmPacmanView methodsFor: 'scripting' stamp: 'FK 12/4/2017 20:34'!animate: aPcmTicker	tick := (tick + 1) \\ (maxTick + 1).	"when i tried this at method move, Pharo froze on saving the change :) "	aPcmTicker fire: [ self animate: aPcmTicker ] after: animationTime! !PcmGhost subclass: #PcmPinky	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmPinky methodsFor: 'accessing' stamp: 'OndrejPleticha 12/27/2017 14:55'!resetOn: aMap	x := 256.	y := 96.	self computeCurrentCoordinate: aMap.	self forceViewRelocate! !!PcmPinky methodsFor: 'accessing' stamp: 'OndrejPleticha 11/27/2017 11:39'!view	^ PcmPinkyView  new model: self ! !PcmGhostView subclass: #PcmPinkyView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmPinkyView methodsFor: 'accessing' stamp: 'FK 12/4/2017 20:42'!background	tick := (tick + 1) \\ (maxTick + 1). "when i tried this at method move, Pharo froze on saving the change :) "	^ BlBackground builder		paint: Color transparent;		image:			((Form fromFileNamed: './pacman_images/ghost3_' , lastDirection direction , '1', '.png')				magnifyBy: 1.4);		opacity: 1;		build! !Announcement subclass: #PcmPointsChanged	instanceVariableNames: 'points'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmPointsChanged methodsFor: 'accessing' stamp: 'AdamPlatkevic 12/17/2017 14:37'!points: anObject	points := anObject! !!PcmPointsChanged methodsFor: 'accessing' stamp: 'AdamPlatkevic 12/17/2017 14:37'!points	^ points! !Object subclass: #PcmRouteFinder	instanceVariableNames: 'startNode endNode fifo map'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/9/2017 16:56'!startNode^ startNode ! !!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/9/2017 16:56'!map: amapmap:= amap! !!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/9/2017 16:55'!startNode: nodestartNode := node! !!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/9/2017 16:56'!endNode^ endNode ! !!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/9/2017 16:56'!endNode: nodeendNode := node! !!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/10/2017 11:33'!getFirstDir: aDict	| curr |	curr := endNode deepCopy.	[ true ]		whileTrue: [ (aDict at: curr) = startNode				ifTrue: [ 					^ map getDirFrom: startNode to: curr ]				ifFalse: [ curr := aDict at: curr ] ]! !!PcmRouteFinder methodsFor: 'running' stamp: 'FK 12/14/2017 00:30'!runFor: aPcmMovingBlock	| closeSet openSet dict parent_state |	startNode = endNode		ifTrue: [ ^ nil ].	closeSet := Set new.	openSet := OrderedCollection new.	dict := Dictionary new.	dict at: self startNode put: nil.	openSet add: self startNode.	[ openSet notEmpty ]		whileTrue: [ parent_state := openSet at: 1.			openSet remove: parent_state.			endNode = parent_state				ifTrue: [ ^ self getFirstDir: dict ].			(map getFreeBlockAround: parent_state for: aPcmMovingBlock)				do: [ :child | 					(closeSet includes: child)						ifFalse: [ (openSet includes: child)								ifFalse: [ dict at: child put: parent_state.									openSet add: child ] ] ].			closeSet add: parent_state ]! !!PcmRouteFinder methodsFor: 'running' stamp: 'ondra 12/9/2017 16:56'!map^ map! !BlElement subclass: #PcmScoreNumberView	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmScoreNumberView commentStamp: 'FK 12/27/2017 23:34' prior: 0!Object for displaying single digit of game score!!PcmScoreNumberView methodsFor: 'initialization' stamp: 'FK 12/26/2017 20:13'!initialize	super initialize.	self size: 18@24.! !!PcmScoreNumberView methodsFor: 'accessing' stamp: 'FK 12/26/2017 19:51'!number	^ number! !!PcmScoreNumberView methodsFor: 'accessing' stamp: 'FK 12/26/2017 19:51'!number: anObject	number := anObject! !!PcmScoreNumberView methodsFor: 'accessing' stamp: 'FK 12/26/2017 19:52'!background	^ BlBackground builder		image:			((Form fromFileNamed: './pacman_images/numbers.png')				 copy: (Rectangle point: (number*18)@0 point: ((number+ 1)*18)@24 ));		opacity: 1;		build! !!PcmScoreNumberView methodsFor: 'drawing' stamp: 'FK 12/26/2017 19:53'!drawOnSpartaCanvas: aCanvas	self background drawOnSpartaCanvas: aCanvas of: self.! !BlElement subclass: #PcmScoreView	instanceVariableNames: 'model'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmScoreView commentStamp: 'FK 12/27/2017 23:35' prior: 0!Object for displaying game score using PcmScoreNumberView!!PcmScoreView methodsFor: 'accessing' stamp: 'FK 12/26/2017 19:50'!model: aPcmGame	model := aPcmGame.	model announcer when: PcmPointsChanged send: #update to: self.! !!PcmScoreView methodsFor: 'accessing' stamp: 'FK 12/26/2017 19:50'!model	^ model! !!PcmScoreView methodsFor: 'initialization' stamp: 'FK 12/26/2017 20:04'!initialize	super initialize.	self layout: BlGridLayout horizontal.	self layout columnCount: 1.	self constraintsDo: [ :aLayoutConstraints | 		aLayoutConstraints horizontal fitContent.		aLayoutConstraints vertical fitContent ].! !!PcmScoreView methodsFor: 'updating' stamp: 'FK 12/27/2017 23:33'!update	| newChild |	self removeChildren.	self layout columnCount: model points asString size.	model points asString do: [ :each |  		newChild := PcmScoreNumberView  new.			newChild number: each digitValue.		self addChild: newChild.	].! !PcmConsumable subclass: #PcmSmallDot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmSmallDot methodsFor: 'testing' stamp: 'FK 12/14/2017 00:12'!view	^ PcmSmallDotView new! !PcmDotView subclass: #PcmSmallDotView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmSmallDotView methodsFor: 'initialization' stamp: 'xxx 12/3/2017 22:30'!initialize	super initialize.	self size: 7 @ 7.! !PcmBlock subclass: #PcmStaticBlock	instanceVariableNames: 'item'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmStaticBlock methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:28'!canGoThroughGhost	self subclassResponsibility! !!PcmStaticBlock methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:28'!canGoThroughPacman	self subclassResponsibility! !!PcmStaticBlock methodsFor: 'testing' stamp: 'FK 12/14/2017 00:13'!canGoThrough: aPcmMovingBlock	self subclassResponsibility! !!PcmStaticBlock methodsFor: 'as yet unclassified' stamp: 'AdamPlatkevic 12/17/2017 13:41'!consumeItem	"item soSomething"	item ifNotNil: [ self announcer announce: PcmItemConsumed new ].	item := nil.! !!PcmStaticBlock methodsFor: 'accessing' stamp: 'xxx 12/3/2017 22:42'!item: anItem	item := anItem! !!PcmStaticBlock methodsFor: 'accessing' stamp: 'xxx 12/3/2017 22:43'!item	^ item! !PcmStaticBlock subclass: #PcmCoridor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmCoridor methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:26'!canGoThroughGhost	^ true! !!PcmCoridor methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:26'!canGoThroughPacman	^ true! !!PcmCoridor methodsFor: 'testing' stamp: 'FK 12/14/2017 00:14'!canGoThrough: aPcmMovingBlock	^ aPcmMovingBlock canGoThroughCoridor! !!PcmCoridor methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:59'!view	^ PcmCoridorView new model: self! !PcmStaticBlock subclass: #PcmGhostDoor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmGhostDoor methodsFor: 'accessing' stamp: 'xxx 11/22/2017 00:46'!view	^ PcmGhostDoorView new model: self! !!PcmGhostDoor methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:26'!canGoThroughGhost	^ true! !!PcmGhostDoor methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:26'!canGoThroughPacman	^ false! !!PcmGhostDoor methodsFor: 'testing' stamp: 'FK 12/14/2017 00:15'!canGoThrough: aPcmMovingBlock	^ aPcmMovingBlock canGoThroughGhostDoor! !PcmBlockView subclass: #PcmStaticBlockView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmStaticBlockView methodsFor: 'drawing' stamp: 'BorisPazdera 12/3/2017 18:19'!drawOnSpartaCanvas: aCanvas	aCanvas fill		paint: self backgroundPaint;		path: self boundsInLocal;		draw! !!PcmStaticBlockView methodsFor: 'accessing' stamp: 'AdamPlatkevic 12/17/2017 13:52'!model: aPcmBlock	model := aPcmBlock.	model item ifNil: [ ^ self ].	self addChild: model item view.	model announcer when: PcmItemConsumed send: #removeChildren to: self.! !!PcmStaticBlockView methodsFor: 'accessing' stamp: 'xxx 11/22/2017 00:41'!backgroundPaint	self subclassResponsibility! !PcmStaticBlockView subclass: #PcmCoridorView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmCoridorView methodsFor: 'accessing' stamp: 'BorisPazdera 12/3/2017 18:20'!backgroundPaint	^ Color black! !PcmStaticBlockView subclass: #PcmGhostDoorView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmGhostDoorView methodsFor: 'accessing' stamp: 'xxx 11/22/2017 00:41'!backgroundPaint	^ Color lightGray! !Object subclass: #PcmTicker	instanceVariableNames: 'running delay block events'	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmTicker commentStamp: 'FK 12/27/2017 23:31' prior: 0!This object is used to shedule events of our game!!PcmTicker methodsFor: 'running' stamp: 'FK 12/27/2017 21:01'!tick	running		ifFalse: [ ^ self ].	events copy		do: [ :each | 			each at: 1 put: (each at: 1) - delay millisecondDelayDuration.			(each at: 1) = 0				ifTrue: [ events remove: each.					(each at: 2) value ] ].	delay wait.	self tick! !!PcmTicker methodsFor: 'running' stamp: 'xxx 11/21/2017 23:05'!run	running := true.	self tick! !!PcmTicker methodsFor: 'accessing' stamp: 'FK 12/4/2017 20:14'!events	^ events ifNil: [ events := OrderedCollection new ]! !!PcmTicker methodsFor: 'accessing' stamp: 'xxx 11/22/2017 19:36'!delay: aNumber	delay := aNumber! !!PcmTicker methodsFor: 'accessing' stamp: 'xxx 11/21/2017 22:39'!running: aBoolean	running := aBoolean! !!PcmTicker methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:04'!block: anObject	block := anObject! !!PcmTicker methodsFor: 'accessing' stamp: 'xxx 11/21/2017 22:39'!stop	running := false! !!PcmTicker methodsFor: 'as yet unclassified' stamp: 'FK 12/4/2017 20:15'!fire: aBlock after: aDuration	self events add: (OrderedCollection new add: aDuration; add: aBlock; yourself )! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PcmTicker class	instanceVariableNames: ''!!PcmTicker class methodsFor: 'as yet unclassified' stamp: 'FK 12/27/2017 23:41'!withTick: aNumber	aNumber < 1		ifTrue: [ self error: 'PcmTicker tick must have duration at least 1 millisecond' ].	^ self basicNew running: false; delay: aNumber milliSeconds asDelay; yourself! !!PcmTicker class methodsFor: 'instance creation' stamp: 'FK 12/27/2017 23:32'!new	self error: 'Instances of this object should be create using withTick: aNumber'! !PcmStaticBlock subclass: #PcmWall	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmWall methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:27'!canGoThroughGhost	^ false! !!PcmWall methodsFor: 'testing' stamp: 'xxx 11/21/2017 22:27'!canGoThroughPacman	^ false! !!PcmWall methodsFor: 'testing' stamp: 'FK 12/14/2017 00:15'!canGoThrough: aPcmMovingBlock	^ aPcmMovingBlock canGoThroughWall! !!PcmWall methodsFor: 'accessing' stamp: 'xxx 11/21/2017 23:58'!view	^ PcmWallView new model: self! !PcmStaticBlockView subclass: #PcmWallView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!PcmWallView methodsFor: 'accessing' stamp: 'xxx 11/22/2017 00:27'!backgroundPaint	^ Color blue! !TestCase subclass: #TestPcmRouteFinder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!TestPcmRouteFinder methodsFor: 'as yet unclassified' stamp: 'ondra 12/10/2017 09:34'!loadMap	| ios currentLine mapView tmpmap |	tmpmap := PcmMap new.	ios := FileStream oldFileNamed: 'map.txt'.	tmpmap columnsCnt: ios nextLine asNumber.	tmpmap rowsCnt: ios nextLine asNumber.	1 to: tmpmap rowsCnt do: [ :i | 		currentLine := ios nextLine.		1 to: tmpmap columnsCnt do: [ :j | 			(currentLine at: j) = $1				ifTrue: [ tmpmap addBlock: PcmWall new ].			(currentLine at: j) = $3				ifTrue: [ tmpmap						addBlock:							(PcmCoridor new								item: PcmSmallDot new;								yourself) ].			(currentLine at: j) = $4				ifTrue: [ tmpmap						addBlock:							(PcmCoridor new								item: PcmBigDot new;								yourself) ].			(currentLine at: j) = $0				ifTrue: [ tmpmap addBlock: PcmCoridor new ].			(currentLine at: j) = $2				ifTrue: [ tmpmap addBlock: PcmGhostDoor new ] ] ].	ios close.	mapView := PcmMapView new mapModel: tmpmap.	^tmpmap! !!TestPcmRouteFinder methodsFor: 'tests' stamp: 'FK 12/14/2017 01:01'!testBFS	| finder |	finder := PcmRouteFinder new.	finder map: self loadMap.	finder endNode: 48.	finder startNode: 17.	self assert: (finder runFor: PcmBlinky new) class equals: PcmDirDown! !BlElement subclass: #TextWithCr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PacmanBloc'!!TextWithCr methodsFor: 'initialization' stamp: 'xxx 12/4/2017 19:28'!initialize	super initialize.	self layout: BlLinearLayout vertical.	self layout alignTopLeft.	self constraintsDo: [ :aLayoutConstraints | 		aLayoutConstraints horizontal fitContent.		aLayoutConstraints vertical fitContent ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextWithCr class	instanceVariableNames: ''!!TextWithCr class methodsFor: 'as yet unclassified' stamp: 'xxx 12/4/2017 19:27'!withText: aString	| el substrings |	el := self new.	substrings := aString findBetweenSubstrings: String cr.	substrings do: [ :each | el addChild: (BlTextElement new text: (BrRopedText string: each)) ].	^ el! !